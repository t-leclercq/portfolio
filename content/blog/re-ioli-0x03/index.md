---
title: "[Reverse Engineering] IOLI 0x03"
date: "2022-02-03T02:10:00.000Z"
description: "From Dustri's « Defeating ioli with radare2 »"
categories: [reverse engineering]
comments: true
image:
  feature: https://raw.githubusercontent.com/t-leclercq/portfolio/main/content/assets/3.png
  credit: z4nzi
---

![Third one...](https://raw.githubusercontent.com/t-leclercq/portfolio/main/content/assets/3.png)

### The same old song...

Crackme0x03 is the same as crackme0x02 but instead of comparing the results inside of the `main` function, the results are passed inside an other function named `test` and the comparison inscrution is executed inside this *test* function.

Then, in order to print a message depending on the outcome of the `cmp` instruction, a string is passed inside a third function named `shift`.

The two strings passed into the shift function are respectively :

- `Lqydolg#Sdvvzrug$`
- `Sdvvzrug#RN$$$#=,`

As seen in pseudocode generated by radare2 decompiler :

```
[0x0804846e]> pdd
/* r2dec pseudo code output */
/* crackme0x03 @ 0x804846e */
#include <stdint.h>
 
int32_t test (int32_t arg_8h, uint32_t arg_ch) {
    eax = arg_8h;
    if (eax != arg_ch) {
        shift ("Lqydolg#Sdvvzrug$");
    } else {
        shift ("Sdvvzrug#RN$$$#=,");
    }
    return eax;
}
[0x0804846e]> exit
```

A shift instruction... well... **shifts** a value to a side or an other.
We can easily deduce that it's a **caesar cipher** operation, also known as caesar *shift*. Let's finds where the value of the shift is set :

```
│      │╎   0x08048445      2c03           sub al, 3
```

Inside the shift function, which take a **char array** in argument, we can see a **subtraction of 3**.

Based on the assumption that this is a Caesar Cipher, let's try to shift it with a python function (thanks to StackOverflow, it took 30 seconds) :

```
❯ python3
Python 3.9.2 (default, Feb 28 2021, 17:03:44) 
[GCC 10.2.1 20210110] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> def ceasar(story, shift):
...   return ''.join([ # concentrate list to string
...             (lambda c, is_upper: c.upper() if is_upper else c) # if original char is upper case than convert result to upper case too
...                 (
...                   ("abcdefghijklmnopqrstuvwxyz"*2)[ord(char.lower()) - ord('a') + shift % 26], # rotate char, this is extra easy since Python accepts list indexs below 0
...                   char.isupper()
...                 )
...             if char.isalpha() else char # if not in alphabet then don't change it
...             for char in story 
...         ])
... 
>>> ceasar('lol', 3)
'oro'
>>> ceasar('Lqydolg#Sdvvzrug$', -3) <======= because we've seen |sub al, 3|
'Invalid#Password$'
>>> ceasar('Sdvvzrug#RN$$$#=,', -3)
'Password#OK$$$#=,'
>>> quit()
```

This explains the two obfuscated strings. ;)